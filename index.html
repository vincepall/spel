<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gekken bekke!</title>
    <!-- Import canvas-confetti for the celebration effects -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <!-- Import face-api.js for facial recognition -->
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@700&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #A0E7E5;
            background-image: radial-gradient(circle at 10% 20%, rgb(255, 252, 213) 0%, rgb(200, 247, 197) 90%);
            font-family: 'Nunito', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            user-select: none;
        }

        /* --- UI Elements --- */
        #game-container {
            position: relative;
            width: 90vw;
            max-width: 800px;
            height: 70vh;
            margin-top: 20px;
            border-radius: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            background: #fff;
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            border: 8px solid #FFB7B2;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 20px;
            transform: scaleX(-1); /* Mirror the webcam */
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 20px;
        }

        /* --- HUD (Heads Up Display) --- */
        .score-board {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #FF9AA2;
            padding: 10px 20px;
            border-radius: 20px;
            color: white;
            font-family: 'Fredoka One', cursive;
            font-size: 1.5rem;
            box-shadow: 0 4px 0 #E27D84;
            z-index: 10;
        }

        .target-emoji-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 30px;
            border-radius: 50px;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            z-index: 10;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .target-emoji {
            font-size: 4rem;
            line-height: 1;
            margin-bottom: 5px;
        }

        .instruction-text {
            font-size: 1.2rem;
            color: #555;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* --- Buttons --- */
        .btn {
            font-family: 'Fredoka One', cursive;
            border: none;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .btn:active {
            transform: scale(0.95);
        }

        #skip-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: #B5EAD7;
            color: #4A8B71;
            padding: 15px 25px;
            border-radius: 20px;
            font-size: 1.2rem;
            box-shadow: 0 5px 0 #8FBCAB;
            z-index: 10;
        }

        /* --- Loading Screen --- */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #FFDAC1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .loader-emoji {
            font-size: 5rem;
            animation: bounce 1s infinite alternate;
        }

        .loading-text {
            margin-top: 20px;
            font-family: 'Fredoka One', cursive;
            font-size: 2rem;
            color: #FF9AA2;
        }

        @keyframes bounce {
            from { transform: translateY(0); }
            to { transform: translateY(-20px); }
        }

        /* --- Success Overlay --- */
        #success-message {
            position: fixed; /* Changed from absolute to fixed */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: #fff;
            padding: 20px;
            width: 90%;
            max-width: 450px;
            max-height: 90vh; /* Prevent getting cut off on small screens */
            overflow-y: auto; /* Scroll if needed */
            border-radius: 30px;
            border: 8px solid #FFB7B2;
            text-align: center;
            z-index: 1000; /* High z-index to appear on top of everything */
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.3);
        }
        
        #success-message.show {
            transform: translate(-50%, -50%) scale(1);
        }

        #success-message h2 {
            margin: 10px 0;
            color: #FF9AA2;
            font-family: 'Fredoka One', cursive;
            font-size: 2.5rem;
        }

        .snapshot-container {
            width: 100%;
            border-radius: 15px;
            overflow: hidden;
            border: 4px solid #eee;
            margin: 10px 0;
            background: #000;
            line-height: 0;
        }

        #win-snapshot {
            width: 100%;
            height: auto;
            display: block;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            width: 100%;
            justify-content: center;
        }

        .action-btn {
            padding: 12px 24px;
            border-radius: 15px;
            font-size: 1.1rem;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .download {
            background-color: #77DD77;
            box-shadow: 0 4px 0 #5Cb85C;
        }

        .next {
            background-color: #FFDAC1;
            color: #FF6F61;
            box-shadow: 0 4px 0 #FFB7B2;
            flex-grow: 1;
        }

        /* --- Feedback Bar --- */
        #confidence-meter {
            position: absolute;
            left: 20px;
            bottom: 30px;
            width: 20px;
            height: 150px;
            background: rgba(255,255,255,0.5);
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            flex-direction: column-reverse;
            z-index: 5;
        }

        #confidence-fill {
            width: 100%;
            height: 0%;
            background: linear-gradient(to top, #FF9AA2, #C7CEEA);
            transition: height 0.1s;
        }

    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loader-emoji">ü§î</div>
        <div class="loading-text">Waking up the robots...</div>
    </div>

    <!-- Main Game Area -->
    <div id="game-container">
        <video id="video" autoplay muted playsinline></video>
        <!-- Canvas for optional face drawing, hidden by default but good for debug -->
        <canvas id="overlay"></canvas>
        
        <!-- UI Overlays -->
        <div class="score-board">
            Score: <span id="score">0</span>
        </div>

        <div id="success-message">
            <h2>AWESOME!</h2>
            <div class="snapshot-container">
                <img id="win-snapshot" alt="Your funny face!">
            </div>
            <div class="action-buttons">
                <a id="download-link" class="btn action-btn download" download="my-funny-face.png">üíæ Save</a>
                <button id="next-level-btn" class="btn action-btn next">Next Face ‚û°Ô∏è</button>
            </div>
        </div>

        <div class="target-emoji-container" id="target-container">
            <div class="target-emoji" id="target-emoji">üòÑ</div>
            <div class="instruction-text" id="target-text">Make a Happy Face!</div>
        </div>

        <button id="skip-btn" class="btn">Skip This One</button>
        
        <!-- Little fun meter to show the child the computer sees them -->
        <div id="confidence-meter" title="Match Strength">
            <div id="confidence-fill"></div>
        </div>
    </div>

    <script>
        // --- Game Configuration ---
        const TARGET_HOLD_TIME = 10; // Number of frames to hold expression to win
        const DETECTION_THRESHOLD = 0.7; // How confident the AI needs to be (0.0 to 1.0)
        
        // Emoji Definitions
        const EMOTIONS = [
            { id: 'happy', emoji: 'üòÑ', text: 'Be Happy!', color: '#FFD700' },
            { id: 'surprised', emoji: 'üò≤', text: 'Be Surprised!', color: '#ADD8E6' },
            { id: 'angry', emoji: 'üò†', text: 'Show a Grumpy Face!', color: '#FF6347', threshold: 0.4 },
            { id: 'sad', emoji: 'üò¢', text: 'Make a Sad Face', color: '#4682B4' },
            // Lower threshold (0.2) makes this very easy to get
            { id: 'disgusted', emoji: 'ü§¢', text: 'Make a Yucky Face!', color: '#8FBC8F', threshold: 0.2 },
            { id: 'fearful', emoji: 'üò±', text: 'Look Scared!', color: '#9370DB', threshold: 0.25 },
            { id: 'neutral', emoji: 'üòê', text: 'Make a Serious Face!', color: '#D3D3D3' },
            // New Variations (Reuse base emotions but with different prompts)
            { id: 'happy', emoji: 'üòÜ', text: 'Laugh Out Loud!', color: '#FFD700' },
            { id: 'surprised', emoji: 'ü§Ø', text: 'Mind Blown!', color: '#87CEEB' },
            { id: 'angry', emoji: 'üò°', text: 'Super Angry!', color: '#B22222', threshold: 0.4 }
        ];

        // --- State ---
        let score = 0;
        let currentEmotionIndex = 0;
        let isModelLoaded = false;
        let isGameRunning = false;
        let matchCounter = 0; // Counts frames where face matches
        let isProcessingWin = false; // Prevent double firing

        // --- DOM Elements ---
        const video = document.getElementById('video');
        const loadingScreen = document.getElementById('loading-screen');
        const targetEmojiEl = document.getElementById('target-emoji');
        const targetTextEl = document.getElementById('target-text');
        const targetContainer = document.getElementById('target-container');
        const scoreEl = document.getElementById('score');
        const skipBtn = document.getElementById('skip-btn');
        const successMsg = document.getElementById('success-message');
        const confidenceFill = document.getElementById('confidence-fill');
        const nextLevelBtn = document.getElementById('next-level-btn');
        const downloadLink = document.getElementById('download-link');
        const winSnapshot = document.getElementById('win-snapshot');

        // --- Audio Controller (Synthesized sounds) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'success') {
                // Happy major arpeggio
                osc.type = 'sine';
                osc.frequency.setValueAtTime(523.25, now); // C5
                osc.frequency.setValueAtTime(659.25, now + 0.1); // E5
                osc.frequency.setValueAtTime(783.99, now + 0.2); // G5
                osc.frequency.setValueAtTime(1046.50, now + 0.3); // C6
                
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
                
                osc.start(now);
                osc.stop(now + 0.6);
            } else if (type === 'skip') {
                // Whoosh sound
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.linearRampToValueAtTime(50, now + 0.2);
                
                gainNode.gain.setValueAtTime(0.2, now);
                gainNode.gain.linearRampToValueAtTime(0.01, now + 0.2);
                
                osc.start(now);
                osc.stop(now + 0.2);
            } else if (type === 'pop') {
                // Short pop
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                
                osc.start(now);
                osc.stop(now + 0.1);
            }
        }

        // --- Game Logic ---

        function pickRandomEmotion() {
            let newIndex;
            do {
                newIndex = Math.floor(Math.random() * EMOTIONS.length);
            } while (newIndex === currentEmotionIndex && EMOTIONS.length > 1);
            
            currentEmotionIndex = newIndex;
            updateUI();
        }

        function updateUI() {
            const emotion = EMOTIONS[currentEmotionIndex];
            targetEmojiEl.innerText = emotion.emoji;
            targetTextEl.innerText = emotion.text;
            
            // Pop animation for the container
            targetContainer.style.transform = "translateX(-50%) scale(0.8)";
            setTimeout(() => {
                targetContainer.style.transform = "translateX(-50%) scale(1)";
            }, 100);
            
            matchCounter = 0;
            confidenceFill.style.height = '0%';
        }

        function captureSnapshot() {
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            
            // Mirror the image context so the saved photo looks like the mirror reflection (what the user sees)
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
            
            // Draw the current video frame
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            // Reset transform to draw text normally (not mirrored)
            ctx.setTransform(1, 0, 0, 1, 0, 0);

            // Draw the target emoji in the top right
            const emotion = EMOTIONS[currentEmotionIndex];
            ctx.font = "80px Arial"; // System font for emojis
            ctx.textAlign = "right";
            ctx.textBaseline = "top";
            
            // Add a little drop shadow to make it pop against any background
            ctx.shadowColor = "rgba(0,0,0,0.5)";
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            // Draw: x = width - 20px padding, y = 20px padding
            ctx.fillText(emotion.emoji, canvas.width - 20, 20);
            
            // Convert to data URL
            const dataUrl = canvas.toDataURL('image/png');
            return dataUrl;
        }

        function handleWin() {
            if (isProcessingWin) return;
            isProcessingWin = true;

            playSound('success');
            
            // Capture the moment!
            const snapshotUrl = captureSnapshot();
            winSnapshot.src = snapshotUrl;
            downloadLink.href = snapshotUrl;
            // Generate a fun filename with timestamp
            downloadLink.download = `emoji-master-${Date.now()}.png`;

            // Confetti explosion
            confetti({
                zIndex: 2000, // Ensure confetti appears ON TOP of the popup
                particleCount: 150,
                spread: 70,
                origin: { y: 0.6 },
                colors: ['#FF9AA2', '#FFB7B2', '#FFDAC1', '#E2F0CB', '#B5EAD7', '#C7CEEA']
            });

            // Show success message with the photo
            successMsg.classList.add('show');
            score++;
            scoreEl.innerText = score;

            // REMOVED Auto-advance code. Now we wait for button click.
        }

        function handleNextLevel() {
            successMsg.classList.remove('show');
            // Small delay to allow fade out
            setTimeout(() => {
                isProcessingWin = false;
                pickRandomEmotion();
            }, 300);
        }

        function handleSkip() {
            if (isProcessingWin) return;
            playSound('skip');
            
            // Small visual feedback
            skipBtn.style.transform = "scale(0.9)";
            setTimeout(() => skipBtn.style.transform = "scale(1)", 100);
            
            pickRandomEmotion();
        }

        // --- Face API Setup ---

        async function loadModels() {
            const MODEL_URL = 'https://justadudewhohacks.github.io/face-api.js/models';
            
            try {
                // Load only what we need for expression detection
                await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
                await faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL);
                startVideo();
            } catch (err) {
                console.error("Error loading models", err);
                document.querySelector('.loading-text').innerText = "Oh no! Could not load the brain.";
            }
        }

        function startVideo() {
            navigator.mediaDevices.getUserMedia({ video: {} })
                .then(stream => {
                    video.srcObject = stream;
                })
                .catch(err => {
                    console.error("Camera denied", err);
                    document.querySelector('.loading-text').innerText = "I need to see you to play! Please allow camera access.";
                });
        }

        video.addEventListener('play', () => {
            isModelLoaded = true;
            loadingScreen.style.display = 'none';
            isGameRunning = true;
            
            // Start the detection loop
            setInterval(async () => {
                if (!isGameRunning || isProcessingWin) return;

                // Detect faces and expressions
                // Using TinyFaceDetector for speed (good for real-time)
                const detections = await faceapi.detectAllFaces(video, new faceapi.TinyFaceDetectorOptions()).withFaceExpressions();

                if (detections.length > 0) {
                    // Get the first face detected
                    const expressions = detections[0].expressions;
                    const targetEmotion = EMOTIONS[currentEmotionIndex];
                    const targetId = targetEmotion.id;
                    const requiredConfidence = targetEmotion.threshold || DETECTION_THRESHOLD;
                    
                    // Check probability of the current target emotion
                    let currentProbability = expressions[targetId];

                    // --- COMPATIBILITY PATCHES ---
                    // "Fear" is very hard for this model; it often looks like "Surprise"
                    // We blend in some of the "Surprised" score to help it register
                    if (targetId === 'fearful') {
                         // Take the actual fear, or half of surprise, whichever is higher
                         currentProbability = Math.max(currentProbability, expressions['surprised'] * 0.5);
                    }
                    
                    // "Disgusted" often looks like "Angry" to the model
                    // Increased the fallback: if it looks even mostly angry (0.7), it counts towards disgust
                    if (targetId === 'disgusted') {
                        currentProbability = Math.max(currentProbability, expressions['angry'] * 0.7);
                    }
                    // -----------------------------

                    // Visual feedback: Scale bar relative to the REQUIRED threshold
                    // So if threshold is 0.4, getting 0.4 fills the bar 100%
                    const percentage = Math.min(100, Math.round((currentProbability / requiredConfidence) * 90));
                    confidenceFill.style.height = `${percentage}%`;
                    
                    // Change color if we are close/winning
                    if (percentage > 90) {
                        confidenceFill.style.backgroundColor = "#77DD77"; // Pastel Green
                    } else {
                        confidenceFill.style.backgroundColor = "#FFB7B2"; // Reset to pink
                    }

                    // Check for win condition
                    if (currentProbability > requiredConfidence) {
                        matchCounter++;
                        if (matchCounter >= TARGET_HOLD_TIME) {
                            handleWin();
                        }
                    } else {
                        // Decay the match counter so you don't lose progress instantly on a glitch
                        matchCounter = Math.max(0, matchCounter - 1);
                    }
                } else {
                    confidenceFill.style.height = '0%';
                }
            }, 100); // Check every 100ms
        });

        // --- Initialization ---
        skipBtn.addEventListener('click', handleSkip);
        nextLevelBtn.addEventListener('click', handleNextLevel);
        
        // Start loading
        loadModels();
        pickRandomEmotion();

    </script>
</body>
</html>
