<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Rocket Runner</title>
  <style>
    :root {
      --bg: #0b1020;
      --fg: #e8f0ff;
      --accent: #7cf2ff;
      --muted: #99a3b3;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    .wrap { min-height: 100%; display: grid; place-items: center; padding: 16px; }
    .panel { width: min(900px, 100%); }
    #game { width: 100%; height: 260px; display: block; border-radius: 16px; background: radial-gradient(1200px 300px at 50% 100%, #162040, #0b1020 60%); box-shadow: 0 15px 40px rgba(0,0,0,.35), inset 0 0 0 1px rgba(124,242,255,.15); touch-action: manipulation; }
    .hud { display: flex; justify-content: space-between; align-items: center; gap: 12px; padding: 10px 2px 0; font-variant-numeric: tabular-nums; }
    .hud .score { font-weight: 700; letter-spacing: .5px; }
    .hud .btns { display: flex; gap: 8px; }
    button { appearance: none; border: none; background: #11172c; color: var(--fg); padding: 10px 14px; border-radius: 12px; cursor: pointer; box-shadow: inset 0 0 0 1px rgba(124,242,255,.2); transition: transform .06s ease, box-shadow .2s ease; }
    button:hover { box-shadow: inset 0 0 0 1px rgba(124,242,255,.35), 0 3px 10px rgba(0,0,0,.25); }
    button:active { transform: translateY(1px); }
    .overlay { position: absolute; inset: 0; display: grid; place-items: center; pointer-events: none; }
    .card { pointer-events: auto; background: rgba(13, 20, 44, .9); border-radius: 16px; padding: 16px 18px; text-align: center; box-shadow: 0 8px 30px rgba(0,0,0,.45), inset 0 0 0 1px rgba(124,242,255,.2); }
    .title { font-size: 20px; margin: 0 0 8px; }
    .muted { color: var(--muted); font-size: 14px; }
    .hidden { display: none; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <div class="hud">
        <div class="score">Score: <span id="score">0</span> ¬∑ High: <span id="hi">0</span></div>
        <div class="btns">
          <button id="btnPause" title="P">‚è∏Ô∏è Pauze</button>
          <button id="btnReset" title="R">üîÑ Opnieuw</button>
        </div>
      </div>
      <div style="position: relative">
        <canvas id="game" width="900" height="260" aria-label="Runner game canvas"></canvas>
        <div id="overlay" class="overlay">
          <div class="card">
            <h2 class="title">üöÄ Rocket Runner</h2>
            <p class="muted">Tik/klik of druk op <b>Spatie</b>/<b>‚Üë</b> om te springen.
              <br>Vermijd astero√Øden en UFO's. Wordt sneller over tijd.</p>
            <p class="muted">P = pauze, R = opnieuw.</p>
            <div style="margin-top:10px"><button id="btnStart">Start</button></div>
          </div>
        </div>
      </div>
      <p class="muted" style="margin:10px 2px 0">Tip: wil je andere sprites? Vervang de tekenfuncties <code>drawRocket</code>, <code>drawAsteroid</code> en <code>drawUFO</code> door <code>drawImage()</code> met je eigen PNG's of SVG's. Zie commentaar in de code.</p>
    </div>
  </div>

  <script>
    // === Utility for crisp canvas on HiDPI ===
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    function fitDPI() {
      const dpr = Math.max(window.devicePixelRatio || 1, 1);
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.round(rect.width * dpr);
      canvas.height = Math.round(rect.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // Scale drawing operations
    }
    fitDPI();
    addEventListener('resize', fitDPI);

    // === Game state ===
    const state = {
      running: false,
      paused: false,
      gameOver: false,
      speed: 6,          // world speed (px/frame baseline)
      speedIncrease: 0.0008, // slow ramp-up per frame
      gravity: 0.7,
      jumpVel: -13,
      groundY: () => canvas.height / (window.devicePixelRatio || 1) - 40, // pixels in CSS units
      t: 0,
      score: 0,
      hi: Number(localStorage.getItem('runnerHighScore') || 0),
      obstacles: [],
      flyers: [],
      stars: [],
      nextObstacleIn: 0,
      nextUFOIn: 600,
      rocket: { x: 60, y: 0, vy: 0, w: 48, h: 36, onGround: true, tilt: 0 },
    };

    document.getElementById('hi').textContent = state.hi;

    // === Input ===
    let pressed = new Set();
    addEventListener('keydown', e => {
      if ([" ", "Spacebar", "ArrowUp"].includes(e.key)) { e.preventDefault(); jump(); }
      if (e.key === 'p' || e.key === 'P') togglePause();
      if (e.key === 'r' || e.key === 'R') reset();
      pressed.add(e.key);
    }, { passive: false });
    addEventListener('keyup', e => pressed.delete(e.key));
    canvas.addEventListener('pointerdown', () => { if (!state.running) start(); else jump(); });

    document.getElementById('btnStart').onclick = () => start();
    document.getElementById('btnPause').onclick = () => togglePause();
    document.getElementById('btnReset').onclick = () => reset();

    function start() {
      if (state.running && !state.gameOver) return;
      hideOverlay();
      Object.assign(state, {
        running: true,
        paused: false,
        gameOver: false,
        speed: 6,
        score: 0,
        obstacles: [],
        flyers: [],
        stars: createStars(),
        nextObstacleIn: 40 + Math.random() * 40,
        nextUFOIn: 600 + Math.random() * 400,
        t: 0,
      });
      state.rocket.y = state.groundY() - state.rocket.h;
      state.rocket.vy = 0;
      loop();
    }

    function reset() { showOverlay(); state.running = false; state.gameOver = false; draw(); }
    function togglePause() { if (!state.running) return; state.paused = !state.paused; if (!state.paused) loop(); }
    function jump() {
      if (!state.running || state.paused) return;
      if (state.rocket.onGround) { state.rocket.vy = state.jumpVel; state.rocket.onGround = false; }
    }

    // === World generation ===
    function createStars() {
      const arr = [];
      const count = Math.round(canvas.width / (window.devicePixelRatio||1) / 4);
      for (let i = 0; i < count; i++) {
        arr.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, r: Math.random() * 1.5 + .2, par: .2 + Math.random() * .8 });
      }
      return arr;
    }

    function maybeSpawn() {
      state.nextObstacleIn--;
      if (state.nextObstacleIn <= 0) {
        const size = 18 + Math.random() * 28;
        state.obstacles.push({ x: canvas.width/(window.devicePixelRatio||1) + 30, y: state.groundY() - size, w: size, h: size, rot: Math.random() * Math.PI });
        state.nextObstacleIn = 40 + Math.random() * 60 + Math.max(0, 40 - state.speed * 3);
      }
      state.nextUFOIn--;
      if (state.nextUFOIn <= 0) {
        const h = 22 + Math.random() * 8;
        const y = state.groundY() - (Math.random() < 0.5 ? 110 : 160) - Math.random() * 40;
        state.flyers.push({ x: canvas.width/(window.devicePixelRatio||1) + 30, y, w: 46, h, bob: Math.random()*6.28 });
        state.nextUFOIn = 480 + Math.random() * 420;
      }
    }

    // === Game loop ===
    let rafId;
    function loop() {
      if (!state.running || state.paused) return;
      update();
      draw();
      rafId = requestAnimationFrame(loop);
    }

    function update() {
      state.t++;
      state.speed += state.speedIncrease; // ramp difficulty
      state.score += state.speed * 0.1; // score scales with speed

      // Rocket physics
      state.rocket.vy += state.gravity;
      state.rocket.y += state.rocket.vy;
      if (state.rocket.y >= state.groundY() - state.rocket.h) {
        state.rocket.y = state.groundY() - state.rocket.h;
        state.rocket.vy = 0; state.rocket.onGround = true;
      }
      state.rocket.tilt = state.rocket.onGround ? 0 : Math.max(-0.35, Math.min(0.35, -state.rocket.vy * 0.03));

      // Obstacles
      maybeSpawn();
      const vx = -state.speed;
      state.obstacles.forEach(o => { o.x += vx; o.rot += 0.06; });
      state.flyers.forEach(f => { f.x += vx * 1.15; f.bob += 0.06; });
      state.obstacles = state.obstacles.filter(o => o.x + o.w > -20);
      state.flyers = state.flyers.filter(f => f.x + f.w > -20);

      // Collisions (AABB with a small inset to be fair)
      const inset = 6;
      const pr = { x: state.rocket.x + inset, y: state.rocket.y + inset, w: state.rocket.w - inset*2, h: state.rocket.h - inset*2 };
      for (const o of state.obstacles) {
        if (rectsOverlap(pr, { x: o.x, y: o.y, w: o.w, h: o.h })) { endGame(); return; }
      }
      for (const f of state.flyers) {
        if (rectsOverlap(pr, { x: f.x, y: f.y, w: f.w, h: f.h })) { endGame(); return; }
      }

      // High score
      if (Math.floor(state.score) > state.hi) {
        state.hi = Math.floor(state.score);
        localStorage.setItem('runnerHighScore', state.hi);
        document.getElementById('hi').textContent = state.hi;
      }
      document.getElementById('score').textContent = Math.floor(state.score);
    }

    function endGame() {
      state.gameOver = true; state.running = false; cancelAnimationFrame(rafId);
      showOverlay(`<h2 class="title">üí• Game Over</h2><p class="muted">Score: <b>${Math.floor(state.score)}</b> ¬∑ High: <b>${state.hi}</b></p><div style="margin-top:10px"><button id=\"btnAgain\">Speel opnieuw</button></div>`);
      document.getElementById('btnAgain').onclick = () => start();
    }

    function rectsOverlap(a, b) { return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

    // === Drawing ===
    function draw() {
      const w = canvas.width / (window.devicePixelRatio || 1);
      const h = canvas.height / (window.devicePixelRatio || 1);
      // Sky
      ctx.clearRect(0, 0, w, h);

      // Stars parallax
      for (const s of state.stars) {
        s.x -= state.speed * 0.1 * s.par; if (s.x < -2) s.x = w + Math.random() * 40; // wrap
        ctx.globalAlpha = 0.6 + 0.4*Math.sin((state.t + s.x) * 0.01);
        ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); ctx.fillStyle = '#cde5ff'; ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Ground line + dashes
      const gy = state.groundY();
      ctx.strokeStyle = 'rgba(124,242,255,.35)';
      ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, gy+0.5); ctx.lineTo(w, gy+0.5); ctx.stroke();
      const dashSpeed = state.speed * 1.1; ctx.lineWidth = 3; ctx.setLineDash([10, 14]); ctx.lineDashOffset = -((state.t * dashSpeed) % 24);
      ctx.strokeStyle = 'rgba(124,242,255,.25)'; ctx.beginPath(); ctx.moveTo(0, gy - 10); ctx.lineTo(w, gy - 10); ctx.stroke(); ctx.setLineDash([]);

      // Obstacles (asteroids)
      for (const o of state.obstacles) drawAsteroid(o.x, o.y, o.w, o.h, o.rot);

      // Flyers (UFOs)
      for (const f of state.flyers) drawUFO(f.x, f.y, f.w, f.h, f.bob);

      // Rocket
      drawRocket(state.rocket.x, state.rocket.y, state.rocket.w, state.rocket.h, state.rocket.tilt, !state.rocket.onGround);
    }

    // === Sprite drawing (replace with your own images if you like) ===
    // To use your own PNGs/SVGs:
    // 1) Create Image objects: const img = new Image(); img.src = 'my.png';
    // 2) In drawRocket / drawAsteroid / drawUFO, replace the vector drawing with ctx.drawImage(img, x, y, w, h)

    function drawRocket(x, y, w, h, tilt=0, inAir=false) {
      ctx.save();
      ctx.translate(x + w/2, y + h/2);
      ctx.rotate(tilt);
      ctx.translate(-w/2, -h/2);
      // body
      roundRect(0, 0, w, h, 10, '#a8d1ff', true, '#5fbef0');
      // window
      ctx.beginPath(); ctx.arc(w*0.6, h*0.45, h*0.18, 0, Math.PI*2); ctx.fillStyle = '#1b2a4a'; ctx.fill();
      ctx.beginPath(); ctx.arc(w*0.6, h*0.45, h*0.12, 0, Math.PI*2); ctx.fillStyle = '#9ad9ff'; ctx.fill();
      // fin
      roundRect(-2, h*0.55, w*0.35, h*0.35, 6, '#7cf2ff', true, '#50b9c7');
      // flame when in air
      if (inAir) {
        const flameLen = 10 + 6*Math.sin(state.t * 0.4);
        ctx.beginPath();
        ctx.moveTo(-6, h*0.55);
        ctx.quadraticCurveTo(-10 - flameLen*0.4, h*0.7, -6, h*0.85);
        ctx.lineTo(-10 - flameLen, h*0.7);
        ctx.closePath();
        const grad = ctx.createLinearGradient(-10 - flameLen, h*0.7, -4, h*0.7);
        grad.addColorStop(0, '#ff9b00'); grad.addColorStop(1, '#ffe98a');
        ctx.fillStyle = grad; ctx.fill();
      }
      ctx.restore();
    }

    function drawAsteroid(x, y, w, h, rot=0) {
      ctx.save(); ctx.translate(x + w/2, y + h/2); ctx.rotate(rot); ctx.translate(-w/2, -h/2);
      ctx.fillStyle = '#9aa3b2'; ctx.strokeStyle = '#6e7a8f'; ctx.lineWidth = 2;
      ctx.beginPath();
      const pts = [
        [w*0.15, h*0.1], [w*0.8, h*0.05], [w*0.95, h*0.45], [w*0.8, h*0.85], [w*0.2, h*0.95], [w*0.05, h*0.5]
      ];
      ctx.moveTo(pts[0][0], pts[0][1]);
      for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0], pts[i][1]);
      ctx.closePath(); ctx.fill(); ctx.stroke();
      // craters
      ctx.fillStyle = '#7b8597';
      for (let i=0;i<3;i++){ ctx.beginPath(); ctx.arc(w*(0.2+Math.random()*0.6), h*(0.2+Math.random()*0.6), Math.min(w,h)*0.08, 0, Math.PI*2); ctx.fill(); }
      ctx.restore();
    }

    function drawUFO(x, y, w, h, bob=0) {
      const yy = y + Math.sin(bob) * 5;
      ctx.save(); ctx.translate(x, yy);
      // beam
      ctx.globalAlpha = 0.12; ctx.fillStyle = '#7cf2ff';
      ctx.beginPath(); ctx.moveTo(w*0.5, h*0.6); ctx.lineTo(w*0.2, h*2.2); ctx.lineTo(w*0.8, h*2.2); ctx.closePath(); ctx.fill(); ctx.globalAlpha = 1;
      // dome
      ctx.fillStyle = '#9ad9ff'; ctx.beginPath(); ctx.ellipse(w*0.5, h*0.35, w*0.28, h*0.25, 0, 0, Math.PI*2); ctx.fill();
      // saucer
      const grad = ctx.createLinearGradient(0,0,w,0); grad.addColorStop(0,'#7cf2ff'); grad.addColorStop(1,'#50b9c7');
      roundRect(0, h*0.45, w, h*0.3, h*0.18, grad, true, '#2f7f8d');
      // lights
      for (let i=0;i<4;i++){ ctx.beginPath(); ctx.arc(w*(0.2+i*0.2), h*0.6, h*0.07, 0, Math.PI*2); ctx.fillStyle = '#ffe98a'; ctx.fill(); }
      ctx.restore();
    }

    function roundRect(x, y, w, h, r, fillStyle, fill=true, strokeStyle=null) {
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y,   x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x,   y+h, rr);
      ctx.arcTo(x,   y+h, x,   y,   rr);
      ctx.arcTo(x,   y,   x+w, y,   rr);
      if (fill) { ctx.fillStyle = fillStyle; ctx.fill(); }
      if (strokeStyle) { ctx.strokeStyle = strokeStyle; ctx.stroke(); }
    }

    // === Overlay helpers ===
    function showOverlay(html) {
      const el = document.getElementById('overlay');
      if (html) el.querySelector('.card').innerHTML = html;
      el.classList.remove('hidden');
    }
    function hideOverlay() { document.getElementById('overlay').classList.add('hidden'); }

    // Initial paint
    state.stars = createStars();
    state.rocket.y = state.groundY() - state.rocket.h;
    draw();
  </script>
</body>
</html>
